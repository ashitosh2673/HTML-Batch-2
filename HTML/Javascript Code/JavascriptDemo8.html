<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      this.name = "ITShaala";
      console.log(this);

      //  In the above the values will be gets added to the window object

      // this is a keyword which refers to the current object.
      //  The value of this depends on in which context it appears: function, class, or global.

      //   this keyword in function
      function myFunction() {
        console.log("this without function : ", this);
      }

      myFunction();

      //   this keyword in object method
      const person = {
        firstName: "John",
        lastName: "Doe",
        fullName: function () {
          console.log("this within function : ", this);

          return this.firstName + " " + this.lastName;
        },
      };

      console.log("this will person object : ", person.fullName());

      //   this keyword in arrow function
      function myFunction() {
        const person = {
          firstName: "John",
          lastName: "Doe",
          fullName: () => {
            console.log("this within function => Arrow function : ", this);
            const person2 = {
              firstName: "John2",
              lastName: "Doe2",
              fullName: () => {
                console.log(
                  "this within function 2 ==> Arrow function : ",
                  this
                );
                return this.firstName + " " + this.lastName;
              },
            };
            person2.fullName("John3", "Doe3");
            return this.firstName + " " + this.lastName;
          },
        };
        person.fullName();
        // console.log("this will person object : ", person.fullName());
        // console.log("this wthout person object : ", this);
      }

      myFunction();

      //   arrow function :
      // An arrow function expression is a compact alternative to a traditional function expression, with some semantic differences and deliberate limitations in usage:
      // Arrow functions don't have their own bindings to this, arguments, or super, and should not be used as methods.
      // Arrow functions cannot be used as constructors. Calling them with new throws a TypeError. They also don't have access to the new.target keyword.
      // Arrow functions cannot use yield within their body and cannot be created as generator functions.
      // An arrow function cannot contain a line break between its parameters and its arrow. For example, the following would fail with a SyntaxError: x =>
      // const func = (a, b, c)
      // => 1;
      // SyntaxError: Unexpected token '=>'

      function add() {
        return 1 + 2;
      }

      console.log(add());

      //   same above function with arrow function

      // const addArrow = () => 1 + 2;
      const addArrow = () => {
        const a = 30;
        const b = 40;
        return [a, b];
      };

      console.log(addArrow());

      const addArrowwithArguments = (firstArg, secondArgs) =>
        firstArg + secondArgs;

      console.log(addArrowwithArguments(1, 2));

      //   const addArrowwithArguments = (firstArg, secondArgs) =>

      const addArrowwithArguments1 = (firstArg, secondArgs) =>
        firstArg + secondArgs;

      console.log(addArrowwithArguments1(1, 2));

      // const studentTest = {
      //   firstName: "John",
      //   lastName: "Doe",
      //   fullName: function () {
      //     return this.firstName + " " + this.lastName;
      //   },
      // };

      // const testObj = new studentTest;
      // console.log("testObj.c()", testObj.fullName());
      //   call method
      //   The call() method calls a function with a given this value and arguments provided individually.
      //   Syntax : function.call(thisArg, arg1, arg2, ...)
      //   Parameters : thisArg : The value of this provided for the call to a function. Note that this may not be the actual value seen by the method: if the method is a function in non-strict mode, null and undefined will be replaced with the global object, and primitive values will be boxed.
      //   arg1, arg2, ... : Arguments for the function.

      //   Example :

      const student = {
        firstName: "John",
        lastName: "Doe",
        fullName: function () {
          return this.firstName + " " + this.lastName;
        },
      };
      const MayurStudent = {
        firstName: "Mayur",
        lastName: "Bhavsar",
      };
      const Saumil = {
        firstName: "Saumil",
        lastName: "Bhavsar",
      };
      console.log("Mayur Call :", student.fullName.call(MayurStudent)); // Will return "Mayur Bhavsar"
      console.log("Saumil Call", student.fullName.call(Saumil)); // Will return "Saumil Bhavsar"

      //   or

      const student1 = {
        firstName: "John",
        lastName: "Doe",
        fullName: function (greet, message) {
          return `${greet} ${this.firstName} ${this.lastName} : ${message}`;
        },
      };
      const MayurStudent1 = {
        firstName: "Mayur",
        lastName: "Bhavsar",
      };
      const Saumil1 = {
        firstName: "Saumil",
        lastName: "Bhavsar",
      };
      console.log(
        "Mayur Call :",
        student1.fullName.call(MayurStudent1, "Hello", "Welcome to my class")
      ); // Will return "Mayur Bhavsar"
      console.log(
        "Saumil Call",
        student1.fullName.call(Saumil1, "Hi", "Welcome to IT Shaala")
      ); // Will return "Saumil Bhavsar"

      //   apply method
      //   The apply() method calls a function with a given this value, and arguments provided as an array (or an array-like object).
      //   Syntax : function.apply(thisArg, [argsArray])
      //   Parameters : thisArg : The value of this provided for the call to a function. Note that this may not be the actual value seen by the method: if the method is a function in non-strict mode, null and undefined will be replaced with the global object, and primitive values will be boxed.
      //   argsArray : An array-like object, specifying the arguments with which func should be called, or null or undefined if no arguments should be provided to the function. Starting with ECMAScript 5 these arguments can be a generic array-like object instead of an array. See below for browser compatibility information.

      //   Example :

      const student2 = {
        firstName: "John",
        lastName: "Doe",
        fullName: function () {
          return this.firstName + " " + this.lastName;
        },
      };

      const MayurStudent2 = {
        firstName: "Mayur",
        lastName: "Bhavsar",
      };

      const Saumil2 = {
        firstName: "Saumil",
        lastName: "Bhavsar",
      };

      console.log("Mayur Call :", student2.fullName.apply(MayurStudent2)); // Will return "Mayur Bhavsar"

      //  or with array arguments

      const student3 = {
        firstName: "John",
        lastName: "Doe",
        fullName: function (greet, message) {
          return `${greet} ${this.firstName} ${this.lastName} : ${message}`;
        },
      };

      const MayurStudent3 = {
        firstName: "Mayur",
        lastName: "Bhavsar",
      };

      const Saumil3 = {
        firstName: "Saumil",
        lastName: "Bhavsar",
      };

      console.log(
        "Mayur Call : verify ",
        student3.fullName.apply(MayurStudent3, ["Hello", "Welcome to my class"])
      ); // Will return "Hello Mayur Bhavsar : Welcome to my class"

      //   bind method
      //   The bind() method creates a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function is called.
      //   Syntax : function.bind(thisArg[, arg1[, arg2[, ...]]])

      //   Parameters : thisArg : The value to be passed as the this parameter to the target function func when the bound function is called. The value is ignored if the bound function is constructed using the new operator. When using bind to create a function (supplied as a callback) inside a setTimeout, any primitive value passed as thisArg is converted to object. If no arguments are provided to bind, the this of the executing scope is treated as the thisArg for the new function.

      //   arg1, arg2, ... : Arguments to prepend to arguments provided to the bound function when invoking the target function.

      //   Example :

      const carObj = {
        model: "BMW",
        price: 1000000,
        getPrice: function (gst) {
          return this.price + gst;
        },
      };

      const carObj1 = {
        model: "Audi",
        price: 2000000,
      };

      const carObj2 = {
        model: "Mercedes",
        price: 3000000,
      };

      const withBind = carObj.getPrice.bind(carObj1);

      //   xtssfdf
      // sdfsfsf

      console.log("withBind", withBind(200000, 300000));
      console.log("withBind1", withBind(200, 3000));
    </script>
  </body>
</html>
